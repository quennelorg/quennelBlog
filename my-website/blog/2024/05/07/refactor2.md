---
slug: refactor2
title: 重构2
authors: quennel
tags: [refactor]
date: 2024-05-07T15:02
---

### code smell（代码的坏味道）
#### 神秘命名(Mysterious Name)
命名是编程中最难的两件事之一。正因为如此，改名可能是最常用的重构手法，包括`改变函数声明、变量改名、字段改名`等。

很多人经常不愿意给程序元素改名，觉得不值得费这个劲，但好的名字能节省未来用在猜谜上的大把时间。 改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。

#### 重复代码(Duplicated Code)
如果你在一个以上的地点看到相同的代码结构，那么可以肯定:设法将它们合而为 一，程序会变得更好。

一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。如果要修改重复代码，你必须找出所有的副本来修改。
- 抽取函数
- 重组代码顺序
- 如果函数在不同子类相同调用，则提取到父类去
#### 过长函数(Long Function)

函数越长，越难理解

- 抽取函数
- 取消临时变量
- 引入参数对象
- 保持对象完整
- 以命令取代函数
- 分解条件表达式
- 多态取代表达式
- 拆分循环

#### 过长参数列表(Long Parameter List)
使用类可以有效的缩短参数列表
#### 全局数据(Global Data)
如果有种数据，在代码库中任何一个角落都可以对这个数据进行操作修改，那么这就很难知道哪段代码对这个数据做出了修改
- 封装变量数据，尽量控制数据的作用域

#### 可变数据(Mutable Data)
对数据的修改经常导致出乎意料的结果和难以发现的bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能失效了——如果故障只在很罕见的情况下发生，要找出故障原因就会更加困难。
- 封装变量，确保数据更新的时候只能通过很少的几个函数进行
- 拆分变量，如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量
- 设计 API 时，可以使用查询函数和修改函数分离

#### 发散式变化(Divergent Change)
在针对软件修改的时候，只希望只针对某一个部分进行修改，如果a需求需要改这4个函数，b需求需要改这4个函数加一个函数，这就是征兆

我们需要把a需求和b需求弄到不同的模块，这样改动就会小很多

#### 霰弹式修改(Shotgun Surgery)
这个与发散式变化相反，如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。

假设需要改动的代码散布四处。你不但非常难找到它们。也非常easy忘记某个重要的改动。

#### 依恋情结(Feature Envy)
所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。

但有时你会发现，一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结的典型情况。

无数次经验里，我们看到某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。

最根本的原则是：将总是一起变化的东西放在一块儿。数据和引用这些数据的行为总是一起变化的。

#### 数据泥团(Data Clumps)
数据项就像小孩子，喜欢成群结队地待在一块儿。你常常可以在很多地方看到相同的三四项数据:两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象

不需要重复的数据类型或者参数，需要把他们放到一个新对象
#### 基本类型偏执(Primitive Obsession)
#### 重复的 switch (Repeated Switches)
多态
#### 循环语句(Loops)
管道操作，map，filter
#### 冗赘的元素(Lazy Element)
如果一些方法或函数被重构的越来越小，则可以删除一些元素
#### 夸夸其谈通用性(Speculative Generality)
#### 临时字段(Temporary Field)
#### 过长的消息链(Message Chains)
#### 中间人(Middle Man)
对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随着委托。

比如，你问主管是否有时间参加一个会议，他就把这个消息“委托”给他的记事簿，然后才能回答你。很好，你没必要知道这位主管到底使用传统记事簿还是使用电子记事簿抑或是秘书来记录自己的约会。

但是人们可能过度运用委托。你也许会看到某个类的接口有一半的函数都委托给其他类，这样就是过度运用。这时应该使用`移除中间人`，直接和真正负责的对象打交道。如果这样“不干实事”的函数只有少数几个，可以运用`内联函数`把它们放进调用端。如果这些中间人还有其他行为，可以运用`以委托取代超类`或者`以委托取代子类`把它变成真正的对象，这样你既可以扩展原对象的行为，又不必负担那么多的委托动作。
#### 内幕交易(Insider Trading)
软件开发者喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。
#### 过大的类(Large Class)
#### 异曲同工的类(Alternative Classes with Different Interfaces)
#### 纯数据类(Data Class)
#### 被拒绝的遗赠(Refused Bequest)
#### 注释(Comments)
> 当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。

如果你不知道该做什么，这才是注释的良好运用时机。除了用来记述将来的打算之外，注释还可以用来标记你并无十足把握的区域。

你可以在注释里写下自己“为什么做某某事”。这类信息可以帮助将来的修改者，尤其是那些健忘的家伙。
